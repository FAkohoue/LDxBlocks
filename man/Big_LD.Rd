% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Big_LD.R
\name{Big_LD}
\alias{Big_LD}
\title{Estimation of LD Block Regions Using Kinship-Adjusted Correlation (\eqn{rV^2})}
\usage{
Big_LD(
  geno,
  SNPinfo,
  CLQcut = 0.5,
  clstgap = 40000,
  leng = 200,
  subSegmSize = 1500,
  MAFcut = 0.05,
  appendrare = FALSE,
  checkLargest = FALSE,
  CLQmode = "Density",
  rV2method = "chol",
  split = FALSE,
  digits = 6,
  seed = NULL,
  verbose = FALSE
)
}
\arguments{
\item{geno}{Numeric matrix/data frame of additive genotypes (individuals x SNPs).}

\item{SNPinfo}{Data frame with 2 columns: col1 = SNP ID (rsID), col2 = base-pair position.}

\item{CLQcut}{Numeric threshold for \eqn{rV^2} (0â€“1) used to define LD cliques. Default: 0.5.}

\item{clstgap}{Integer. Maximum physical gap (bp) allowed within a clique.}

\item{leng}{Integer. Window size for weak-LD boundary checks during segmentation. Default: 200.}

\item{subSegmSize}{Integer. Max SNPs in a sub-segment (segments above are split). Default: 1500.}

\item{MAFcut}{Numeric. Minor allele frequency threshold (exclude below unless \code{appendrare=TRUE}). Default: 0.05.}

\item{appendrare}{Logical. If TRUE, appends rare SNPs after block construction. Default: FALSE.}

\item{checkLargest}{Logical. Fast clique detection in large regions via dense-core decomposition. Default: FALSE.}

\item{CLQmode}{Character. Clique prioritization: \code{"Density"} (default) or \code{"Maximal"}.}

\item{rV2method}{\code{"chol"} (default) or \code{"eigen"} for computing \eqn{V^{-1/2}}.}

\item{split}{Logical. If TRUE, allow splitting cliques over long distances. Default: FALSE.}

\item{digits}{Integer; decimals for rounding \eqn{rV^2} inside \code{compute_rV2()}. Default: \code{6}.}

\item{seed}{Integer or \code{NULL}. If non-\code{NULL}, \code{set.seed(seed)} is called. Default: \code{NULL}.}

\item{verbose}{Logical; if \code{TRUE}, print progress messages. Default: \code{FALSE}.}
}
\value{
\code{data.frame} of detected LD blocks with columns:
\describe{
\item{start}{SNP index of block start (including monomorphic SNPs).}
\item{end}{SNP index of block end.}
\item{start.rsID, end.rsID}{SNP IDs at block boundaries.}
\item{start.bp, end.bp}{Base-pair positions of block boundaries.}
}
}
\description{
Detects linkage disequilibrium (LD) blocks in SNP genotype data using a Big-LD style approach
with kinship-adjusted squared correlation (\eqn{rV^2}). Suitable for related or structured populations.
}
\examples{
\donttest{
## No test:
set.seed(1)

# Small synthetic data with two strong LD blocks
m  <- 80          # individuals
b1 <- 60          # SNPs in block 1
b2 <- 60          # SNPs in block 2

make_block <- function(m, size, p, flip = 0.03) {
  # Start from a common "founder" SNP and create near-duplicates
  seed <- rbinom(m, 2, p)
  M <- matrix(seed, nrow = m, ncol = size)
  for (j in seq_len(size)) {
    idx <- sample.int(m, max(1, floor(flip * m)))
    delta <- sample(c(-1, 1), length(idx), replace = TRUE)
    M[idx, j] <- pmin(2, pmax(0, M[idx, j] + delta))  # keep in 0/1/2
  }
  M
}

G <- cbind(
  make_block(m, b1, p = 0.30, flip = 0.03),
  make_block(m, b2, p = 0.60, flip = 0.03)
)

colnames(G) <- paste0("rs", seq_len(ncol(G)))
rownames(G) <- paste0("ind", seq_len(nrow(G)))  # required so G.tuneup has names

# Positions: two blocks separated by a large genomic gap
pos <- c(
  seq(1,    by = 1000, length.out = b1),
  seq(5e6,  by = 1000, length.out = b2)
)
SNPinfo <- data.frame(SNP = colnames(G), POS = pos)

# Run with small windows so the example is quick & stable
blocks <- Big_LD(G, SNPinfo, CLQcut = 0.6, leng = 30, subSegmSize = 120, verbose = FALSE)
head(blocks)
## End(No test)
}

}
\seealso{
\code{\link{CLQD}}, \code{\link{compute_rV2}}, \code{\link{get_V_inv_sqrt}}, \code{\link{run_Big_LD_all_chr}}
}
